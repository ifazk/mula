<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mula__Match (mula.Mula__Match)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">mula</a> &#x00BB; Mula__Match</nav><h1>Module <code>Mula__Match</code></h1><h2 id="universal-levenshtein-automata"><a href="#universal-levenshtein-automata" class="anchor"></a>Universal Levenshtein Automata</h2><p>The <a href="https://hal.archives-ouvertes.fr/hal-01360482/file/LATA2016.pdf">paper by Touzet</a> details the Universal Levenshtein Automata.</p><p>Some nice computational properties of the (not-deterministic) automata include:</p><ul><li>There are no epsilon transitions.</li><li>The automata are computable on demand, there is no need to store states and transitions in a data structure.</li><li>The states of the automata carry error counts.</li><li>There is a simple subsumption relation that prunes sets of states, so transitions produce small sets of states.</li></ul><p>These allow for efficient implementation together with interesting uses.</p><ol><li>We not only know if two strings are within a certain edit distance, but we also know what the edit distance is if they are within the edit distance limit.</li><li>If several strings are compared, we can rank them by their edit distance.</li><li>We can lazily feed characters and string fragments to the atomata and get the current error count.</li></ol><nav class="toc"><ul><li><a href="#string-abstraction">String Abstraction</a></li><li><a href="#levenshtein-automata">Levenshtein Automata</a></li></ul></nav></header><aside><p>This module offers a functor to build matchers for different representations of strings and characters. For a prebuilt matcher for OCaml strings and characters, see <code>Strings</code>.</p></aside><section><header><h3 id="string-abstraction"><a href="#string-abstraction" class="anchor"></a>String Abstraction</h3><p>We abstract over strings and characters so that we do not rely on any specific encoding. We only need the following:</p><ul><li>a function to compute length of strings,</li><li>a function to fetch a character at an index, and</li><li>a function to check if two characters are equal.</li></ul></header><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="levenshtein-automata"><a href="#levenshtein-automata" class="anchor"></a>Levenshtein Automata</h3><p>Given a string representation, we produce two Automata:</p><ul><li><a href="Make/Lev/index.html"><code>Make.Lev</code></a>, for the standard Levenshtein distance.</li><li><a href="Make/Dem/index.html"><code>Make.Dem</code></a>, for the Demarau-Levenshtein distance which includes transpositions as a primitve edit operation.</li></ul></header><div class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-St/index.html">St</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>